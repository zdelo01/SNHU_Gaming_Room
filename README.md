# SNHU_Gaming_Room
Software Design Document
Zachary DeLong

# Briefly summarize The Gaming Room client and their software requirements. Who was the client? What type of software did they want you to design?
My client the Gaming Room requested help with expanding their game app “Draw it or Lose it” across multiple platforms. 

# What did you do particularly well in developing this documentation?
Something I did well in this document was creating a concise executive summary that explained the client’s software requirements and what we need to know before we started development.

# What about the process of working through a design document did you find helpful when developing the code?
Working through a design document was beneficial as it served as a guideline to follow when developing code.

# If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it? 
I would revise the evaluation part of my document by including more advantages and disadvantages across the various platforms for the most effective comparison between the systems.

# How did you interpret the user’s needs and implement them into your software design? Why is it so important to consider the user’s needs when designing? 
I interpreted the user’s request for the “Draw it or Lose it” game to be compatible with clients across various platforms by developing a backend on Linux OS that can network with other operating systems. It is very important to keep in mind the user's needs when designing otherwise you could deliver a product that serves no value to the customer.

# How did you approach designing software? What techniques or strategies would you use in the future to analyze and design a similar software application?
I approached designing software by breaking down the requirements given by the clients before anything else and then proceeded to design the software around the software requirements. This documentation was a successful strategy for planning out the client’s game app. I will apply these techniques in the future when designing similar software applications. 
